/* tslint:disable */
/* eslint-disable */
/**
 * Neurelo API Spec
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { type Configuration, Configuration as ConfigurationClass, neureloConfig } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, BaseAPI, RequiredError, operationServerMap, globalAxios } from './base';

/**
 * 
 * @export
 * @interface AffectedRowsOutput
 */
export interface AffectedRowsOutput {
    /**
     * 
     * @type {number}
     * @memberof AffectedRowsOutput
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface AggregateLanding
 */
export interface AggregateLanding {
    /**
     * 
     * @type {LandingCountAggregateOutputType}
     * @memberof AggregateLanding
     */
    '_count'?: LandingCountAggregateOutputType;
    /**
     * 
     * @type {LandingMaxAggregateOutputType}
     * @memberof AggregateLanding
     */
    '_max'?: LandingMaxAggregateOutputType;
    /**
     * 
     * @type {LandingMinAggregateOutputType}
     * @memberof AggregateLanding
     */
    '_min'?: LandingMinAggregateOutputType;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {object}
     * @memberof ErrorResponse
     */
    'details'?: object;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface FindLanding400Response
 */
export interface FindLanding400Response {
    /**
     * 
     * @type {Array<ErrorResponse>}
     * @memberof FindLanding400Response
     */
    'errors': Array<ErrorResponse>;
}
/**
 * 
 * @export
 * @interface Landing
 */
export interface Landing {
    /**
     * 
     * @type {string}
     * @memberof Landing
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface LandingAggregateInput
 */
export interface LandingAggregateInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof LandingAggregateInput
     */
    '_count'?: Array<LandingAggregateInputCountEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LandingAggregateInput
     */
    '_max'?: Array<LandingAggregateInputMaxEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LandingAggregateInput
     */
    '_min'?: Array<LandingAggregateInputMinEnum>;
}

export const LandingAggregateInputCountEnum = {
    All: '_all',
    Id: 'id'
} as const;

export type LandingAggregateInputCountEnum = typeof LandingAggregateInputCountEnum[keyof typeof LandingAggregateInputCountEnum];
export const LandingAggregateInputMaxEnum = {
    Id: 'id'
} as const;

export type LandingAggregateInputMaxEnum = typeof LandingAggregateInputMaxEnum[keyof typeof LandingAggregateInputMaxEnum];
export const LandingAggregateInputMinEnum = {
    Id: 'id'
} as const;

export type LandingAggregateInputMinEnum = typeof LandingAggregateInputMinEnum[keyof typeof LandingAggregateInputMinEnum];

/**
 * 
 * @export
 * @interface LandingCountAggregateOutputType
 */
export interface LandingCountAggregateOutputType {
    /**
     * 
     * @type {number}
     * @memberof LandingCountAggregateOutputType
     */
    '_all'?: number;
    /**
     * 
     * @type {number}
     * @memberof LandingCountAggregateOutputType
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface LandingCountOrderByAggregateInput
 */
export interface LandingCountOrderByAggregateInput {
    /**
     * 
     * @type {SortOrder}
     * @memberof LandingCountOrderByAggregateInput
     */
    'id'?: SortOrder;
}


/**
 * 
 * @export
 * @interface LandingCreateInput
 */
export interface LandingCreateInput {
    /**
     * 
     * @type {string}
     * @memberof LandingCreateInput
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface LandingCreateManyInput
 */
export interface LandingCreateManyInput {
    /**
     * 
     * @type {string}
     * @memberof LandingCreateManyInput
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface LandingGroupByInput
 */
export interface LandingGroupByInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof LandingGroupByInput
     */
    '_count'?: Array<LandingGroupByInputCountEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LandingGroupByInput
     */
    '_max'?: Array<LandingGroupByInputMaxEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LandingGroupByInput
     */
    '_min'?: Array<LandingGroupByInputMinEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof LandingGroupByInput
     */
    'id'?: boolean;
}

export const LandingGroupByInputCountEnum = {
    All: '_all',
    Id: 'id'
} as const;

export type LandingGroupByInputCountEnum = typeof LandingGroupByInputCountEnum[keyof typeof LandingGroupByInputCountEnum];
export const LandingGroupByInputMaxEnum = {
    Id: 'id'
} as const;

export type LandingGroupByInputMaxEnum = typeof LandingGroupByInputMaxEnum[keyof typeof LandingGroupByInputMaxEnum];
export const LandingGroupByInputMinEnum = {
    Id: 'id'
} as const;

export type LandingGroupByInputMinEnum = typeof LandingGroupByInputMinEnum[keyof typeof LandingGroupByInputMinEnum];

/**
 * 
 * @export
 * @interface LandingGroupByOutputType
 */
export interface LandingGroupByOutputType {
    /**
     * 
     * @type {LandingCountAggregateOutputType}
     * @memberof LandingGroupByOutputType
     */
    '_count'?: LandingCountAggregateOutputType;
    /**
     * 
     * @type {LandingMaxAggregateOutputType}
     * @memberof LandingGroupByOutputType
     */
    '_max'?: LandingMaxAggregateOutputType;
    /**
     * 
     * @type {LandingMinAggregateOutputType}
     * @memberof LandingGroupByOutputType
     */
    '_min'?: LandingMinAggregateOutputType;
    /**
     * 
     * @type {string}
     * @memberof LandingGroupByOutputType
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface LandingMaxAggregateOutputType
 */
export interface LandingMaxAggregateOutputType {
    /**
     * 
     * @type {string}
     * @memberof LandingMaxAggregateOutputType
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface LandingMaxOrderByAggregateInput
 */
export interface LandingMaxOrderByAggregateInput {
    /**
     * 
     * @type {SortOrder}
     * @memberof LandingMaxOrderByAggregateInput
     */
    'id'?: SortOrder;
}


/**
 * 
 * @export
 * @interface LandingMinAggregateOutputType
 */
export interface LandingMinAggregateOutputType {
    /**
     * 
     * @type {string}
     * @memberof LandingMinAggregateOutputType
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface LandingMinOrderByAggregateInput
 */
export interface LandingMinOrderByAggregateInput {
    /**
     * 
     * @type {SortOrder}
     * @memberof LandingMinOrderByAggregateInput
     */
    'id'?: SortOrder;
}


/**
 * 
 * @export
 * @interface LandingOrderByWithAggregationInput
 */
export interface LandingOrderByWithAggregationInput {
    /**
     * 
     * @type {LandingCountOrderByAggregateInput}
     * @memberof LandingOrderByWithAggregationInput
     */
    '_count'?: LandingCountOrderByAggregateInput;
    /**
     * 
     * @type {LandingMaxOrderByAggregateInput}
     * @memberof LandingOrderByWithAggregationInput
     */
    '_max'?: LandingMaxOrderByAggregateInput;
    /**
     * 
     * @type {LandingMinOrderByAggregateInput}
     * @memberof LandingOrderByWithAggregationInput
     */
    '_min'?: LandingMinOrderByAggregateInput;
    /**
     * 
     * @type {SortOrder}
     * @memberof LandingOrderByWithAggregationInput
     */
    'id'?: SortOrder;
}


/**
 * 
 * @export
 * @interface LandingOrderByWithRelationInput
 */
export interface LandingOrderByWithRelationInput {
    /**
     * 
     * @type {SortOrder}
     * @memberof LandingOrderByWithRelationInput
     */
    'id'?: SortOrder;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const LandingScalarFieldEnum = {
    Id: 'id'
} as const;

export type LandingScalarFieldEnum = typeof LandingScalarFieldEnum[keyof typeof LandingScalarFieldEnum];


/**
 * 
 * @export
 * @interface LandingScalarWhereWithAggregatesInput
 */
export interface LandingScalarWhereWithAggregatesInput {
    /**
     * 
     * @type {LandingScalarWhereWithAggregatesInputAND}
     * @memberof LandingScalarWhereWithAggregatesInput
     */
    'AND'?: LandingScalarWhereWithAggregatesInputAND;
    /**
     * 
     * @type {LandingScalarWhereWithAggregatesInputAND}
     * @memberof LandingScalarWhereWithAggregatesInput
     */
    'NOT'?: LandingScalarWhereWithAggregatesInputAND;
    /**
     * 
     * @type {Array<LandingScalarWhereWithAggregatesInput>}
     * @memberof LandingScalarWhereWithAggregatesInput
     */
    'OR'?: Array<LandingScalarWhereWithAggregatesInput>;
    /**
     * 
     * @type {LandingScalarWhereWithAggregatesInputId}
     * @memberof LandingScalarWhereWithAggregatesInput
     */
    'id'?: LandingScalarWhereWithAggregatesInputId;
}
/**
 * @type LandingScalarWhereWithAggregatesInputAND
 * @export
 */
export type LandingScalarWhereWithAggregatesInputAND = Array<LandingScalarWhereWithAggregatesInput> | LandingScalarWhereWithAggregatesInput;

/**
 * @type LandingScalarWhereWithAggregatesInputId
 * @export
 */
export type LandingScalarWhereWithAggregatesInputId = StringWithAggregatesFilter | string;

/**
 * 
 * @export
 * @interface LandingSelectInput
 */
export interface LandingSelectInput {
    /**
     * 
     * @type {boolean}
     * @memberof LandingSelectInput
     */
    '$related'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LandingSelectInput
     */
    '$scalars'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LandingSelectInput
     */
    'id'?: boolean;
}
/**
 * 
 * @export
 * @interface LandingWhereInput
 */
export interface LandingWhereInput {
    /**
     * 
     * @type {LandingWhereInputAND}
     * @memberof LandingWhereInput
     */
    'AND'?: LandingWhereInputAND;
    /**
     * 
     * @type {LandingWhereInputAND}
     * @memberof LandingWhereInput
     */
    'NOT'?: LandingWhereInputAND;
    /**
     * 
     * @type {Array<LandingWhereInput>}
     * @memberof LandingWhereInput
     */
    'OR'?: Array<LandingWhereInput>;
    /**
     * 
     * @type {LandingWhereInputId}
     * @memberof LandingWhereInput
     */
    'id'?: LandingWhereInputId;
}
/**
 * @type LandingWhereInputAND
 * @export
 */
export type LandingWhereInputAND = Array<LandingWhereInput> | LandingWhereInput;

/**
 * @type LandingWhereInputId
 * @export
 */
export type LandingWhereInputId = StringFilter | string;

/**
 * 
 * @export
 * @interface LandingWhereUniqueInput
 */
export interface LandingWhereUniqueInput {
    /**
     * 
     * @type {string}
     * @memberof LandingWhereUniqueInput
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface NestedIntFilter
 */
export interface NestedIntFilter {
    /**
     * 
     * @type {number}
     * @memberof NestedIntFilter
     */
    'eq'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedIntFilter
     */
    'equals'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedIntFilter
     */
    'gt'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedIntFilter
     */
    'gte'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof NestedIntFilter
     */
    'in'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof NestedIntFilter
     */
    'lt'?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedIntFilter
     */
    'lte'?: number;
    /**
     * 
     * @type {NestedIntFilterNot}
     * @memberof NestedIntFilter
     */
    'not'?: NestedIntFilterNot;
    /**
     * 
     * @type {Array<number>}
     * @memberof NestedIntFilter
     */
    'notIn'?: Array<number>;
}
/**
 * @type NestedIntFilterNot
 * @export
 */
export type NestedIntFilterNot = NestedIntFilter | number;

/**
 * 
 * @export
 * @interface NestedStringFilter
 */
export interface NestedStringFilter {
    /**
     * 
     * @type {string}
     * @memberof NestedStringFilter
     */
    'contains'?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedStringFilter
     */
    'endsWith'?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedStringFilter
     */
    'eq'?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedStringFilter
     */
    'equals'?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedStringFilter
     */
    'gt'?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedStringFilter
     */
    'gte'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NestedStringFilter
     */
    'in'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NestedStringFilter
     */
    'lt'?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedStringFilter
     */
    'lte'?: string;
    /**
     * 
     * @type {NestedStringFilterNot}
     * @memberof NestedStringFilter
     */
    'not'?: NestedStringFilterNot;
    /**
     * 
     * @type {Array<string>}
     * @memberof NestedStringFilter
     */
    'notIn'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NestedStringFilter
     */
    'startsWith'?: string;
}
/**
 * @type NestedStringFilterNot
 * @export
 */
export type NestedStringFilterNot = NestedStringFilter | string;

/**
 * 
 * @export
 * @interface NestedStringWithAggregatesFilter
 */
export interface NestedStringWithAggregatesFilter {
    /**
     * 
     * @type {NestedIntFilter}
     * @memberof NestedStringWithAggregatesFilter
     */
    '_count'?: NestedIntFilter;
    /**
     * 
     * @type {NestedStringFilter}
     * @memberof NestedStringWithAggregatesFilter
     */
    '_max'?: NestedStringFilter;
    /**
     * 
     * @type {NestedStringFilter}
     * @memberof NestedStringWithAggregatesFilter
     */
    '_min'?: NestedStringFilter;
    /**
     * 
     * @type {string}
     * @memberof NestedStringWithAggregatesFilter
     */
    'contains'?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedStringWithAggregatesFilter
     */
    'endsWith'?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedStringWithAggregatesFilter
     */
    'eq'?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedStringWithAggregatesFilter
     */
    'equals'?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedStringWithAggregatesFilter
     */
    'gt'?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedStringWithAggregatesFilter
     */
    'gte'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NestedStringWithAggregatesFilter
     */
    'in'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NestedStringWithAggregatesFilter
     */
    'lt'?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedStringWithAggregatesFilter
     */
    'lte'?: string;
    /**
     * 
     * @type {NestedStringWithAggregatesFilterNot}
     * @memberof NestedStringWithAggregatesFilter
     */
    'not'?: NestedStringWithAggregatesFilterNot;
    /**
     * 
     * @type {Array<string>}
     * @memberof NestedStringWithAggregatesFilter
     */
    'notIn'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NestedStringWithAggregatesFilter
     */
    'startsWith'?: string;
}
/**
 * @type NestedStringWithAggregatesFilterNot
 * @export
 */
export type NestedStringWithAggregatesFilterNot = NestedStringWithAggregatesFilter | string;

/**
 * 
 * @export
 * @enum {string}
 */

export const QueryMode = {
    Default: 'default',
    Insensitive: 'insensitive'
} as const;

export type QueryMode = typeof QueryMode[keyof typeof QueryMode];


/**
 * 
 * @export
 * @enum {string}
 */

export const SortOrder = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortOrder = typeof SortOrder[keyof typeof SortOrder];


/**
 * 
 * @export
 * @interface StringFilter
 */
export interface StringFilter {
    /**
     * 
     * @type {string}
     * @memberof StringFilter
     */
    'contains'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringFilter
     */
    'endsWith'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringFilter
     */
    'eq'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringFilter
     */
    'equals'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringFilter
     */
    'gt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringFilter
     */
    'gte'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StringFilter
     */
    'in'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof StringFilter
     */
    'lt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringFilter
     */
    'lte'?: string;
    /**
     * 
     * @type {QueryMode}
     * @memberof StringFilter
     */
    'mode'?: QueryMode;
    /**
     * 
     * @type {NestedStringFilterNot}
     * @memberof StringFilter
     */
    'not'?: NestedStringFilterNot;
    /**
     * 
     * @type {Array<string>}
     * @memberof StringFilter
     */
    'notIn'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof StringFilter
     */
    'startsWith'?: string;
}


/**
 * 
 * @export
 * @interface StringWithAggregatesFilter
 */
export interface StringWithAggregatesFilter {
    /**
     * 
     * @type {NestedIntFilter}
     * @memberof StringWithAggregatesFilter
     */
    '_count'?: NestedIntFilter;
    /**
     * 
     * @type {NestedStringFilter}
     * @memberof StringWithAggregatesFilter
     */
    '_max'?: NestedStringFilter;
    /**
     * 
     * @type {NestedStringFilter}
     * @memberof StringWithAggregatesFilter
     */
    '_min'?: NestedStringFilter;
    /**
     * 
     * @type {string}
     * @memberof StringWithAggregatesFilter
     */
    'contains'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringWithAggregatesFilter
     */
    'endsWith'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringWithAggregatesFilter
     */
    'eq'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringWithAggregatesFilter
     */
    'equals'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringWithAggregatesFilter
     */
    'gt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringWithAggregatesFilter
     */
    'gte'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StringWithAggregatesFilter
     */
    'in'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof StringWithAggregatesFilter
     */
    'lt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringWithAggregatesFilter
     */
    'lte'?: string;
    /**
     * 
     * @type {QueryMode}
     * @memberof StringWithAggregatesFilter
     */
    'mode'?: QueryMode;
    /**
     * 
     * @type {NestedStringWithAggregatesFilterNot}
     * @memberof StringWithAggregatesFilter
     */
    'not'?: NestedStringWithAggregatesFilterNot;
    /**
     * 
     * @type {Array<string>}
     * @memberof StringWithAggregatesFilter
     */
    'notIn'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof StringWithAggregatesFilter
     */
    'startsWith'?: string;
}




/**
 * LandingApi - axios parameter creator
 * @export
 */
export const LandingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Aggregate by landing
         * @param {LandingAggregateInput} select 
         * @param {LandingWhereInput} [filter] 
         * @param {Array<LandingOrderByWithRelationInput>} [orderBy] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateByLanding: async (select: LandingAggregateInput, filter?: LandingWhereInput, orderBy?: Array<LandingOrderByWithRelationInput>, skip?: number, take?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'select' is not null or undefined
            assertParamExists('aggregateByLanding', 'select', select)
            const localVarPath = `/rest/landing/__aggregate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create multiple landing records
         * @param {Array<LandingCreateManyInput>} landingCreateManyInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManyLanding: async (landingCreateManyInput: Array<LandingCreateManyInput>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'landingCreateManyInput' is not null or undefined
            assertParamExists('createManyLanding', 'landingCreateManyInput', landingCreateManyInput)
            const localVarPath = `/rest/landing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(landingCreateManyInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create one landing record
         * @param {LandingCreateInput} landingCreateInput 
         * @param {LandingSelectInput} [select] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOneLanding: async (landingCreateInput: LandingCreateInput, select?: LandingSelectInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'landingCreateInput' is not null or undefined
            assertParamExists('createOneLanding', 'landingCreateInput', landingCreateInput)
            const localVarPath = `/rest/landing/__one`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(landingCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple landing records
         * @param {LandingWhereInput} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLanding: async (filter?: LandingWhereInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/landing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete one landing record by id
         * @param {string} value 
         * @param {LandingSelectInput} [select] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLandingById: async (value: string, select?: LandingSelectInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'value' is not null or undefined
            assertParamExists('deleteLandingById', 'value', value)
            const localVarPath = `/rest/landing/{value}`
                .replace(`{${"value"}}`, String(value));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve multiple landing records
         * @param {LandingSelectInput} [select] 
         * @param {LandingWhereInput} [filter] 
         * @param {Array<LandingOrderByWithRelationInput>} [orderBy] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLanding: async (select?: LandingSelectInput, filter?: LandingWhereInput, orderBy?: Array<LandingOrderByWithRelationInput>, skip?: number, take?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/landing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find one landing record by id
         * @param {string} value 
         * @param {LandingSelectInput} [select] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLandingById: async (value: string, select?: LandingSelectInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'value' is not null or undefined
            assertParamExists('findLandingById', 'value', value)
            const localVarPath = `/rest/landing/{value}`
                .replace(`{${"value"}}`, String(value));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Group by landing
         * @param {LandingGroupByInput} select 
         * @param {LandingWhereInput} [filter] 
         * @param {Array<LandingOrderByWithAggregationInput>} [orderBy] 
         * @param {Array<LandingScalarFieldEnum>} [groupBy] 
         * @param {LandingScalarWhereWithAggregatesInput} [having] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupByLanding: async (select: LandingGroupByInput, filter?: LandingWhereInput, orderBy?: Array<LandingOrderByWithAggregationInput>, groupBy?: Array<LandingScalarFieldEnum>, having?: LandingScalarWhereWithAggregatesInput, skip?: number, take?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'select' is not null or undefined
            assertParamExists('groupByLanding', 'select', select)
            const localVarPath = `/rest/landing/__groupBy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (having !== undefined) {
                localVarQueryParameter['having'] = having;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple landing records
         * @param {object} body 
         * @param {LandingWhereInput} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLanding: async (body: object, filter?: LandingWhereInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateLanding', 'body', body)
            const localVarPath = `/rest/landing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update one landing record by id
         * @param {string} value 
         * @param {object} body 
         * @param {LandingSelectInput} [select] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLandingById: async (value: string, body: object, select?: LandingSelectInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'value' is not null or undefined
            assertParamExists('updateLandingById', 'value', value)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateLandingById', 'body', body)
            const localVarPath = `/rest/landing/{value}`
                .replace(`{${"value"}}`, String(value));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LandingApi - functional programming interface
 * @export
 */
export const LandingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LandingApiAxiosParamCreator(configuration)
    return {
        /**
         * Aggregate by landing
         * @param {LandingAggregateInput} select 
         * @param {LandingWhereInput} [filter] 
         * @param {Array<LandingOrderByWithRelationInput>} [orderBy] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregateByLanding(select: LandingAggregateInput, filter?: LandingWhereInput, orderBy?: Array<LandingOrderByWithRelationInput>, skip?: number, take?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aggregateByLanding(select, filter, orderBy, skip, take, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LandingApi.aggregateByLanding']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create multiple landing records
         * @param {Array<LandingCreateManyInput>} landingCreateManyInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createManyLanding(landingCreateManyInput: Array<LandingCreateManyInput>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createManyLanding(landingCreateManyInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LandingApi.createManyLanding']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create one landing record
         * @param {LandingCreateInput} landingCreateInput 
         * @param {LandingSelectInput} [select] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOneLanding(landingCreateInput: LandingCreateInput, select?: LandingSelectInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOneLanding(landingCreateInput, select, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LandingApi.createOneLanding']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete multiple landing records
         * @param {LandingWhereInput} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLanding(filter?: LandingWhereInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLanding(filter, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LandingApi.deleteLanding']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete one landing record by id
         * @param {string} value 
         * @param {LandingSelectInput} [select] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLandingById(value: string, select?: LandingSelectInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLandingById(value, select, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LandingApi.deleteLandingById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve multiple landing records
         * @param {LandingSelectInput} [select] 
         * @param {LandingWhereInput} [filter] 
         * @param {Array<LandingOrderByWithRelationInput>} [orderBy] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findLanding(select?: LandingSelectInput, filter?: LandingWhereInput, orderBy?: Array<LandingOrderByWithRelationInput>, skip?: number, take?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findLanding(select, filter, orderBy, skip, take, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LandingApi.findLanding']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Find one landing record by id
         * @param {string} value 
         * @param {LandingSelectInput} [select] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findLandingById(value: string, select?: LandingSelectInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findLandingById(value, select, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LandingApi.findLandingById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Group by landing
         * @param {LandingGroupByInput} select 
         * @param {LandingWhereInput} [filter] 
         * @param {Array<LandingOrderByWithAggregationInput>} [orderBy] 
         * @param {Array<LandingScalarFieldEnum>} [groupBy] 
         * @param {LandingScalarWhereWithAggregatesInput} [having] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupByLanding(select: LandingGroupByInput, filter?: LandingWhereInput, orderBy?: Array<LandingOrderByWithAggregationInput>, groupBy?: Array<LandingScalarFieldEnum>, having?: LandingScalarWhereWithAggregatesInput, skip?: number, take?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupByLanding(select, filter, orderBy, groupBy, having, skip, take, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LandingApi.groupByLanding']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update multiple landing records
         * @param {object} body 
         * @param {LandingWhereInput} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLanding(body: object, filter?: LandingWhereInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLanding(body, filter, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LandingApi.updateLanding']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update one landing record by id
         * @param {string} value 
         * @param {object} body 
         * @param {LandingSelectInput} [select] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLandingById(value: string, body: object, select?: LandingSelectInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLandingById(value, body, select, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LandingApi.updateLandingById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * LandingApi - factory interface
 * @export
 */
export const LandingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LandingApiFp(configuration)
    return {
        /**
         * Aggregate by landing
         * @param {LandingAggregateInput} select 
         * @param {LandingWhereInput} [filter] 
         * @param {Array<LandingOrderByWithRelationInput>} [orderBy] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateByLanding(select: LandingAggregateInput, filter?: LandingWhereInput, orderBy?: Array<LandingOrderByWithRelationInput>, skip?: number, take?: number, options?: any): AxiosPromise<void> {
            return localVarFp.aggregateByLanding(select, filter, orderBy, skip, take, options).then((request) => request(axios, basePath));
        },
        /**
         * Create multiple landing records
         * @param {Array<LandingCreateManyInput>} landingCreateManyInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManyLanding(landingCreateManyInput: Array<LandingCreateManyInput>, options?: any): AxiosPromise<void> {
            return localVarFp.createManyLanding(landingCreateManyInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create one landing record
         * @param {LandingCreateInput} landingCreateInput 
         * @param {LandingSelectInput} [select] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOneLanding(landingCreateInput: LandingCreateInput, select?: LandingSelectInput, options?: any): AxiosPromise<void> {
            return localVarFp.createOneLanding(landingCreateInput, select, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple landing records
         * @param {LandingWhereInput} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLanding(filter?: LandingWhereInput, options?: any): AxiosPromise<void> {
            return localVarFp.deleteLanding(filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete one landing record by id
         * @param {string} value 
         * @param {LandingSelectInput} [select] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLandingById(value: string, select?: LandingSelectInput, options?: any): AxiosPromise<void> {
            return localVarFp.deleteLandingById(value, select, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve multiple landing records
         * @param {LandingSelectInput} [select] 
         * @param {LandingWhereInput} [filter] 
         * @param {Array<LandingOrderByWithRelationInput>} [orderBy] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLanding(select?: LandingSelectInput, filter?: LandingWhereInput, orderBy?: Array<LandingOrderByWithRelationInput>, skip?: number, take?: number, options?: any): AxiosPromise<void> {
            return localVarFp.findLanding(select, filter, orderBy, skip, take, options).then((request) => request(axios, basePath));
        },
        /**
         * Find one landing record by id
         * @param {string} value 
         * @param {LandingSelectInput} [select] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLandingById(value: string, select?: LandingSelectInput, options?: any): AxiosPromise<void> {
            return localVarFp.findLandingById(value, select, options).then((request) => request(axios, basePath));
        },
        /**
         * Group by landing
         * @param {LandingGroupByInput} select 
         * @param {LandingWhereInput} [filter] 
         * @param {Array<LandingOrderByWithAggregationInput>} [orderBy] 
         * @param {Array<LandingScalarFieldEnum>} [groupBy] 
         * @param {LandingScalarWhereWithAggregatesInput} [having] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupByLanding(select: LandingGroupByInput, filter?: LandingWhereInput, orderBy?: Array<LandingOrderByWithAggregationInput>, groupBy?: Array<LandingScalarFieldEnum>, having?: LandingScalarWhereWithAggregatesInput, skip?: number, take?: number, options?: any): AxiosPromise<void> {
            return localVarFp.groupByLanding(select, filter, orderBy, groupBy, having, skip, take, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple landing records
         * @param {object} body 
         * @param {LandingWhereInput} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLanding(body: object, filter?: LandingWhereInput, options?: any): AxiosPromise<void> {
            return localVarFp.updateLanding(body, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Update one landing record by id
         * @param {string} value 
         * @param {object} body 
         * @param {LandingSelectInput} [select] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLandingById(value: string, body: object, select?: LandingSelectInput, options?: any): AxiosPromise<void> {
            return localVarFp.updateLandingById(value, body, select, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LandingApi - object-oriented interface
 * @export
 * @class LandingApi
 * @extends {BaseAPI}
 */
export class LandingApi extends BaseAPI {
    /**
     * Aggregate by landing
     * @param {LandingAggregateInput} select 
     * @param {LandingWhereInput} [filter] 
     * @param {Array<LandingOrderByWithRelationInput>} [orderBy] 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LandingApi
     */
    public aggregateByLanding(select: LandingAggregateInput, filter?: LandingWhereInput, orderBy?: Array<LandingOrderByWithRelationInput>, skip?: number, take?: number, options?: RawAxiosRequestConfig) {
        return LandingApiFp(this.configuration).aggregateByLanding(select, filter, orderBy, skip, take, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create multiple landing records
     * @param {Array<LandingCreateManyInput>} landingCreateManyInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LandingApi
     */
    public createManyLanding(landingCreateManyInput: Array<LandingCreateManyInput>, options?: RawAxiosRequestConfig) {
        return LandingApiFp(this.configuration).createManyLanding(landingCreateManyInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create one landing record
     * @param {LandingCreateInput} landingCreateInput 
     * @param {LandingSelectInput} [select] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LandingApi
     */
    public createOneLanding(landingCreateInput: LandingCreateInput, select?: LandingSelectInput, options?: RawAxiosRequestConfig) {
        return LandingApiFp(this.configuration).createOneLanding(landingCreateInput, select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple landing records
     * @param {LandingWhereInput} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LandingApi
     */
    public deleteLanding(filter?: LandingWhereInput, options?: RawAxiosRequestConfig) {
        return LandingApiFp(this.configuration).deleteLanding(filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete one landing record by id
     * @param {string} value 
     * @param {LandingSelectInput} [select] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LandingApi
     */
    public deleteLandingById(value: string, select?: LandingSelectInput, options?: RawAxiosRequestConfig) {
        return LandingApiFp(this.configuration).deleteLandingById(value, select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve multiple landing records
     * @param {LandingSelectInput} [select] 
     * @param {LandingWhereInput} [filter] 
     * @param {Array<LandingOrderByWithRelationInput>} [orderBy] 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LandingApi
     */
    public findLanding(select?: LandingSelectInput, filter?: LandingWhereInput, orderBy?: Array<LandingOrderByWithRelationInput>, skip?: number, take?: number, options?: RawAxiosRequestConfig) {
        return LandingApiFp(this.configuration).findLanding(select, filter, orderBy, skip, take, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find one landing record by id
     * @param {string} value 
     * @param {LandingSelectInput} [select] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LandingApi
     */
    public findLandingById(value: string, select?: LandingSelectInput, options?: RawAxiosRequestConfig) {
        return LandingApiFp(this.configuration).findLandingById(value, select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Group by landing
     * @param {LandingGroupByInput} select 
     * @param {LandingWhereInput} [filter] 
     * @param {Array<LandingOrderByWithAggregationInput>} [orderBy] 
     * @param {Array<LandingScalarFieldEnum>} [groupBy] 
     * @param {LandingScalarWhereWithAggregatesInput} [having] 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LandingApi
     */
    public groupByLanding(select: LandingGroupByInput, filter?: LandingWhereInput, orderBy?: Array<LandingOrderByWithAggregationInput>, groupBy?: Array<LandingScalarFieldEnum>, having?: LandingScalarWhereWithAggregatesInput, skip?: number, take?: number, options?: RawAxiosRequestConfig) {
        return LandingApiFp(this.configuration).groupByLanding(select, filter, orderBy, groupBy, having, skip, take, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple landing records
     * @param {object} body 
     * @param {LandingWhereInput} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LandingApi
     */
    public updateLanding(body: object, filter?: LandingWhereInput, options?: RawAxiosRequestConfig) {
        return LandingApiFp(this.configuration).updateLanding(body, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update one landing record by id
     * @param {string} value 
     * @param {object} body 
     * @param {LandingSelectInput} [select] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LandingApi
     */
    public updateLandingById(value: string, body: object, select?: LandingSelectInput, options?: RawAxiosRequestConfig) {
        return LandingApiFp(this.configuration).updateLandingById(value, body, select, options).then((request) => request(this.axios, this.basePath));
    }
}
export const LandingApiService = new LandingApi(neureloConfig);



